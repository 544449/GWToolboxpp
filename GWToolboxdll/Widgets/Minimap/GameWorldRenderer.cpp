#include "stdafx.h"

#include <GWCA/Context/MapContext.h>
#include <GWCA/GameContainers/GamePos.h>
#include <GWCA/GameEntities/Pathing.h>
#include <GWCA/Managers/CameraMgr.h>
#include <GWCA/Managers/MapMgr.h>
#include <GWCA/Managers/RenderMgr.h>

#include <Defines.h>
#include <Widgets/Minimap/GameWorldRenderer.h>
#include <Widgets/Minimap/Minimap.h>

// Note: these two files are autogenerated by CMake!
#include "Shaders/game_world_renderer_ps.h"
#include "Shaders/game_world_renderer_vs.h"

namespace {
    unsigned lerp_steps_per_line = 10;
    float render_max_distance = 500.f;
    bool need_sync_markers = true;
    bool need_configure_pipeline = true;
    GW::Vec2f lerp(const GW::Vec2f& A, const GW::Vec2f& B, const float t)
    {
        return A * t + B * (1.f - t);
    }
    constexpr auto ALTITUDE_UNKNOWN = std::numeric_limits<float>::max();

    std::vector<GW::Vec2f> circular_points_from_marker(const float pos_x, const float pos_y, const float size)
    {
        std::vector<GW::Vec2f> points;
        constexpr float pi = DirectX::XM_PI;
        constexpr size_t num_points_per_circle = 48;
        constexpr auto slice = 2.0f * pi / static_cast<float>(num_points_per_circle);
        for (auto i = 0u; i < num_points_per_circle; i++) {
            const auto angle = slice * static_cast<float>(i);
            points.push_back(GW::Vec2f{pos_x + size * std::cos(angle), pos_y + size * std::sin(angle)});
        }
        points.push_back(points.at(0)); // to complete the line list
        return points;
    }
} // namespace

GenericPolyRenderable::GenericPolyRenderable(IDirect3DDevice9* device, const GW::Constants::MapID map_id, const std::vector<GW::Vec2f>& points, const unsigned int col, const bool filled)
    : map_id(map_id)
    , col(col)
    , points(points)
    , filled(filled)
    , all_altitudes_queried(false)
{
    if (filled && points.size() >= 3) {
        // (filling doesn't make sense if there is not at least enough points for one triangle)
        std::vector<GW::Vec2f> lerp_points;
        for (size_t i = 0; i < points.size(); i++) {
            const GW::Vec2f& pt = points.at(i);
            if (!lerp_points.empty() && lerp_steps_per_line > 0) {
                for (auto j = 1u; j < lerp_steps_per_line; j++) {
                    const float div = static_cast<float>(j) / static_cast<float>(lerp_steps_per_line);
                    GW::Vec2f split = lerp(points[i], points[i - 1], div);
                    lerp_points.push_back(split);
                }
            }
            lerp_points.push_back(pt);
        }
        const auto poly = std::vector{{lerp_points}};
        const std::vector<unsigned> indices = mapbox::earcut<unsigned>(poly);
        for (size_t i = 0; i < indices.size(); i++) {
            const auto& pt = lerp_points.at(indices.at(i));
            vertices.push_back(D3DVertex{pt.x, pt.y, ALTITUDE_UNKNOWN, col});
        }
    }
    else {
        for (size_t i = 0; i < points.size(); i++) {
            const GW::Vec2f& pt = points.at(i);
            if (!vertices.empty() && lerp_steps_per_line > 0) {
                for (auto j = 1u; j < lerp_steps_per_line; j++) {
                    const auto div = static_cast<float>(j) / static_cast<float>(lerp_steps_per_line);
                    const auto split = lerp(points[i], points[i - 1], div);
                    vertices.push_back(D3DVertex{split.x, split.y, ALTITUDE_UNKNOWN, col});
                }
            }
            vertices.push_back(D3DVertex{pt.x, pt.y, ALTITUDE_UNKNOWN, col});
        }
    }

    device->CreateVertexBuffer(vertices.size() * sizeof(D3DVertex), D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_MANAGED, &vb, nullptr);
}

GenericPolyRenderable::~GenericPolyRenderable()
{
    if (vb != nullptr) {
        vb->Release();
    }
}

void GenericPolyRenderable::Draw(IDirect3DDevice9* device)
{
    // draw this specific renderable
    if (device->SetStreamSource(0, vb, 0, sizeof(D3DVertex)) != D3D_OK) {
        // a safe failure mode
        return;
    }
    // update altitudes if not done already
    if (!all_altitudes_queried) {
        // altitudes (Z value) for each vertex can't be known until we are in the correct map,
        // so these are dynamically computed, one-time.
        float altitude = ALTITUDE_UNKNOWN;

        // in order to properly query altitudes, we have to use the pathing map
        // to determine the number of Z planes in the current map.
        const GW::PathingMapArray* pathing_map = GW::Map::GetPathingMap();
        if (pathing_map != nullptr) {
            const size_t pmap_size = pathing_map->size();
            if (pmap_size > 0) {
                for (size_t i = 0; i < vertices.size(); i++) {
                    // until we have a better solution, all Z planes will be queried per vertex
                    // to avoid a significant delay in the render thread, query one plane per frame
                    // until all have been queried. this might result in some renderables shifting
                    // slightly during first map load for approx <1 second, but IMO is better than
                    // stalling. It seems to take, even in most extreme cases, less time than it takes
                    // for agents to appear.
                    GW::Map::QueryAltitude({vertices[i].x, vertices[i].y, cur_altitude}, 0.1f, altitude);
                    if (altitude < vertices[i].z) { // recall that the Up camera component is inverted
                        vertices[i].z = altitude;
                    }
                }
                if (cur_altitude++ == pmap_size - 1) {
                    all_altitudes_queried = true;
                }

                void* mem_loc = nullptr;
                // map the vertex buffer memory and write vertices to it.
                if (vb->Lock(0, vertices.size() * sizeof(D3DVertex), &mem_loc, D3DLOCK_DISCARD) == S_OK && mem_loc != nullptr) {
                    // this should avoid an invalid memcpy, if locking fails for some reason
                    memcpy(mem_loc, vertices.data(), vertices.size() * sizeof(D3DVertex));
                    vb->Unlock();
                }
            }
        }
    }
    // copy the vertex buffer to the back buffer
    filled ? device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, vertices.size() / 3) : device->DrawPrimitive(D3DPT_LINESTRIP, 0, vertices.size() - 1);
}

bool GameWorldRenderer::SetD3DTransform(IDirect3DDevice9* device, const GW::Camera* cam)
{
    // set up directX standard view/proj matrices according to those used to render the game world
    if (cam == nullptr || device == nullptr) {
        return false;
    }

    constexpr auto vertex_shader_view_matrix_offset = 0u;
    constexpr auto vertex_shader_proj_matrix_offset = 4u;

    // compute view matrix:

    DirectX::XMFLOAT4X4A mat_view{};
    DirectX::XMFLOAT3 eye_pos = {cam->position.x, cam->position.y, cam->position.z};
    DirectX::XMFLOAT3 player_pos = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z};
    static constexpr const DirectX::XMFLOAT3 up = {0.0f, 0.0f, -1.0f};
    // clang-format off
    DirectX::XMStoreFloat4x4A(&mat_view,
        DirectX::XMMatrixTranspose(
            DirectX::XMMatrixLookAtLH(XMLoadFloat3(&eye_pos), XMLoadFloat3(&player_pos), XMLoadFloat3(&up))
        )
    );
    // clang-format on
    if (device->SetVertexShaderConstantF(vertex_shader_view_matrix_offset, (const float*)&mat_view, 4) != D3D_OK) {
        GWCA_ERR("GameWorldRenderer: unable to SetVertexShaderConstantF(view), aborting render.");
        return false;
    }
    // compute projection matrix:
    DirectX::XMFLOAT4X4A mat_proj{};
    // compute the "actual" field of view. GW uses a different value than reported by `camera->field_of_view`.
    float apparent_fov = cam->field_of_view;
    static constexpr float dividend = 1.0f + (2.0f / 3.0f); // this is constant
    float actual_fov = static_cast<float>(atan2(1.0f, dividend / tan(apparent_fov * 0.5f)) * 2.0f);
    float aspect_ratio = static_cast<float>(GW::Render::GetViewportWidth()) / static_cast<float>(GW::Render::GetViewportHeight());

    // clang-format off
    DirectX::XMStoreFloat4x4A(&mat_proj,
        DirectX::XMMatrixTranspose(
            DirectX::XMMatrixPerspectiveFovLH(actual_fov, aspect_ratio, 0.1f, 100000.0f)
        )
    );
    // clang-format on
    if (device->SetVertexShaderConstantF(vertex_shader_proj_matrix_offset, (const float*)&mat_proj, 4) != D3D_OK) {
        GWCA_ERR("GameWorldRenderer: unable to SetVertexShaderConstantF(projection), aborting render.");
        return false;
    }

    return true;
}

void GameWorldRenderer::Render(IDirect3DDevice9* device)
{
    if (need_sync_markers) {
        // marker synchronisation is done when needed on the render thread, as it requires access
        // to the directX device for creating vertex buffers.
        SyncAllMarkers(device);
    }
    if (renderables.empty()) {
        // as both a performance optimisation, and a safety feature, if there are no renderables,
        // i.e. nothing ticked "Draw On Terrain", then no extra directX stuff will happen here.
        // that means that it'll not hit performance much, and also, if there is some bug with
        // the rendering, TB can at least continue to function.
        return;
    }
    if (need_configure_pipeline) {
        if (!ConfigureProgrammablePipeline(device)) {
            return;
        }
    }

    if (GW::Map::GetInstanceType() == GW::Constants::InstanceType::Loading) {
        // perhaps not actually needed, but it's here to be safe.
        return;
    }

    // backup original immediate state and transforms:
    DWORD old_D3DRS_SCISSORTESTENABLE;
    DWORD old_D3DRS_STENCILENABLE;
    device->GetRenderState(D3DRS_SCISSORTESTENABLE, &old_D3DRS_SCISSORTESTENABLE);
    device->GetRenderState(D3DRS_STENCILENABLE, &old_D3DRS_STENCILENABLE);

    // no scissor test / stencil (used by minimap)
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, false);
    device->SetRenderState(D3DRS_STENCILENABLE, false);

    if (vshader == nullptr || device->SetVertexShader(vshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetVertexShader, aborting render.");
        return;
    }
    if (pshader == nullptr || device->SetPixelShader(pshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetPixelShader, aborting render.");
        return;
    }
    if (device->SetVertexDeclaration(vertex_declaration) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetVertexShader declaration, aborting render.");
        return;
    }
    const GW::Camera* cam = GW::CameraMgr::GetCamera();
    if (cam != nullptr) {
        // unsure if can ever be nullptr here, but failure mode is at least clean.
        if (!SetD3DTransform(device, cam)) {
            return;
        }

        // set Pixel Shader constants. they are always expressed as Float4 here:
        // first is the player's position

        constexpr auto pixel_shader_cur_pos_offset = 0u;
        constexpr auto pixel_shader_max_dist_offset = 1u;

        const float cur_pos_constant[4] = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z, 0.0f};
        if (device->SetPixelShaderConstantF(pixel_shader_cur_pos_offset, cur_pos_constant, 1) != D3D_OK) {
            Log::Error("GameWorldRenderer: unable to SetPixelShaderConstantF#0, aborting render.");
            return;
        }

        // second is the render max distance
        const float max_dist_constant[4] = {render_max_distance, 0.0f, 0.0f, 0.0f};
        if (device->SetPixelShaderConstantF(pixel_shader_max_dist_offset, max_dist_constant, 1) != D3D_OK) {
            Log::Error("GameWorldRenderer: unable to SetPixelShaderConstantF#1, aborting render.");
            return;
        }

        const auto map_id = GW::Map::GetMapID();
        renderables_mutex.lock();
        for (const auto& renderable : renderables) {
            // future consideration: should we really render markers on terrain that have MapID=None?
            if (renderable->map_id == GW::Constants::MapID::None || renderable->map_id == map_id) {
                renderable->Draw(device);
            }
        }
        renderables_mutex.unlock();
    }

    // restore immediate state:
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, old_D3DRS_SCISSORTESTENABLE);
    device->SetRenderState(D3DRS_STENCILENABLE, old_D3DRS_STENCILENABLE);
}

bool GameWorldRenderer::ConfigureProgrammablePipeline(IDirect3DDevice9* device)
{
    constexpr D3DVERTEXELEMENT9 decl[] = {{0, 0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0}, {0, 12, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 0}, D3DDECL_END()};
    if (device->CreateVertexDeclaration(decl, &vertex_declaration) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to CreateVertexDeclaration");
        return false;
    }

    if (device->CreateVertexShader(reinterpret_cast<const DWORD*>(&g_vs20_main), &vshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    if (device->CreatePixelShader(reinterpret_cast<const DWORD*>(&g_ps20_main), &pshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    need_configure_pipeline = false;
    return true;
}

void GameWorldRenderer::LoadSettings(const ToolboxIni* ini, const char* section)
{
    // load the rendering settings from disk
    render_max_distance = static_cast<float>(ini->GetDoubleValue(section, VAR_NAME(render_max_distance), render_max_distance));
    lerp_steps_per_line = ini->GetLongValue(section, VAR_NAME(lerp_steps_per_line), lerp_steps_per_line);
}

void GameWorldRenderer::SaveSettings(ToolboxIni* ini, const char* section)
{
    // save the rendering settings to disk
    ini->SetDoubleValue(section, VAR_NAME(render_max_distance), render_max_distance);
    ini->SetLongValue(section, VAR_NAME(lerp_steps_per_line), lerp_steps_per_line);
}

void GameWorldRenderer::DrawSettings()
{
    // draw the settings using ImGui
    const auto red = ImGui::ColorConvertU32ToFloat4(Colors::Red());
    ImGui::TextColored(red, "Warning: This is a beta feature and may render over your character or game props, or not work at all while the U map is open.");
    ImGui::Text("Note: custom markers are only rendered in-game if the option is enabled for a particular marker (check settings).");
    need_sync_markers |= ImGui::DragFloat("Maximum render distance", &render_max_distance, 5.f, 0.f, 10000.f);
    ImGui::ShowHelp("Maximum distance to render custom markers on the in-game terrain.");
    need_sync_markers |= ImGui::DragInt("Interpolation granularity", reinterpret_cast<int*>(&lerp_steps_per_line), 1.0f, 0, 100);
    ImGui::ShowHelp("Number of points to interpolate. Affects smoothness of rendering.");
}

void GameWorldRenderer::TriggerSyncAllMarkers()
{
    // a publicly accessible function to trigger a re-sync of all custom markers
    need_sync_markers = true;
}

void GameWorldRenderer::Terminate()
{
    // free up any vertex buffers
    renderables.clear();
}

void GameWorldRenderer::SyncAllMarkers(IDirect3DDevice9* device)
{
    // as a performance optimisation, the distance comparison skips sqrt calculation,
    // so we pre-calculate the squared value ahead of time.
    renderables_mutex.lock();
    renderables.clear();
    SyncLines(device);
    SyncPolys(device);
    SyncMarkers(device);
    renderables_mutex.unlock();
    need_sync_markers = false;
}

void GameWorldRenderer::SyncLines(IDirect3DDevice9* device)
{
    // sync lines with CustomRenderer
    const auto& lines = Minimap::Instance().custom_renderer.GetLines();
    // for each line, add as a renderable if appropriate
    for (const auto& line : lines) {
        if (!line.draw_on_terrain || !line.visible) {
            continue;
        }
        std::vector points = {line.p1, line.p2};
        renderables.push_back(std::make_unique<GenericPolyRenderable>(device, line.map, points, line.color, false));
    }
}

void GameWorldRenderer::SyncPolys(IDirect3DDevice9* device)
{
    // sync polygons with CustomRenderer
    const auto& polys = Minimap::Instance().custom_renderer.GetPolys();
    // for each poly, add as a renderable if appropriate
    for (const auto& poly : polys) {
        if (!poly.draw_on_terrain || !poly.visible) {
            continue;
        }
        if (poly.points.empty()) {
            continue;
        }
        renderables.push_back(std::make_unique<GenericPolyRenderable>(device, poly.map, poly.points, poly.color, poly.filled));
    }
}

void GameWorldRenderer::SyncMarkers(IDirect3DDevice9* device)
{
    // sync markers with CustomRenderer
    const auto& markers = Minimap::Instance().custom_renderer.GetMarkers();
    // for each marker, add as a renderable if appropriate
    for (const auto& marker : markers) {
        if (!marker.draw_on_terrain || !marker.visible) {
            continue;
        }
        std::vector<GW::Vec2f> points = circular_points_from_marker(marker.pos.x, marker.pos.y, marker.size);
        renderables.push_back(std::make_unique<GenericPolyRenderable>(device, marker.map, points, marker.color, marker.IsFilled()));
    }
}
